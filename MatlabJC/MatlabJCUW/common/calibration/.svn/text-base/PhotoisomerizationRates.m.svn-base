% TOOLS FOR ESTIMATING PHOTOISOMERIZATION RATES FROM LED SPECTRA% load macaque cone spectra - these are energy spectral sensitivitiesload macaque-cone-spectraload macaque-rod-spectra% convert to quantal spectral sensitivities and normalizeMacaqueConeQuantalSpectra = MacaqueConeEnergySpectra;for cone=2:4	MacaqueConeQuantalSpectra(:, cone) = MacaqueConeEnergySpectra(:, cone) .* MacaqueConeEnergySpectra(:, 1);	MacaqueConeQuantalSpectra(:, cone) = MacaqueConeQuantalSpectra(:, cone) / max(MacaqueConeQuantalSpectra(:, cone));end% for rod isolation, lose S coneif (0)	MacaqueConeQuantalSpectra(:, 4) = MacaqueRodQuantalSpectra(:, 2);end% plot spectrasubplot(1, 2, 1);plot(MacaqueConeQuantalSpectra(:, 1), MacaqueConeQuantalSpectra(:, 2), MacaqueConeQuantalSpectra(:, 1), MacaqueConeQuantalSpectra(:, 3), MacaqueConeQuantalSpectra(:, 1), MacaqueConeQuantalSpectra(:, 4))% load measured led spectra from ascii files - from CVI these are quantal spectra%load LEDSpectraNewGreen%load RigALEDSpectraload RigALEDSpectra% UDT powers for each LED (in W)UDTPower(2) = 1e-9;UDTPower(3) = 1e-9;UDTPower(4) = 1e-9;% convert quantal LED spectra to energy spectra and apply udt factors, then convert back to quantal spectra, % now in absolute unitsFlashArea = 290^2 * 3.14159;ScFact = 6.6e-34 * 3e8;LEDEnergySpectra = LEDQuantalSpectra;for led=2:4	LEDEnergySpectra(:, led) = LEDQuantalSpectra(:, led) ./ LEDQuantalSpectra(:, 1);	LEDPow(led) = sum(LEDEnergySpectra(:, led)) * (LEDEnergySpectra(2, 1) - LEDEnergySpectra(1, 1));	LEDEnergySpectra(:, led) = LEDEnergySpectra(:, led) * UDTPower(led) / LEDPow(led);	Spectra(:, led) = LEDEnergySpectra(:, led) .* LEDEnergySpectra(:, 1) * 1e-9 / (ScFact * FlashArea);endsubplot(1, 2, 2);plot(Spectra(:, 1), Spectra(:, 2), Spectra(:, 1), Spectra(:, 3), Spectra(:, 1), Spectra(:, 4))plot(LEDEnergySpectra(:, 1), LEDEnergySpectra(:, 2), LEDEnergySpectra(:, 1), LEDEnergySpectra(:, 3), LEDEnergySpectra(:, 1), LEDEnergySpectra(:, 4))% multiply LED spectra by cone spectra: matrix has columns that are R, G, B% leds, rows are L, M, S conesfor led=2:4	for cone = 2:4		PhotonFlux(cone-1, led-1) = sum(Spectra(:, led) .* MacaqueConeQuantalSpectra(:, cone));	endend% cone isolating: inverse - matrix has columns that are L, M, S cones, rows% are R, G, B ledsConeIsolating = inv(PhotonFlux);for cone = 1:3	ConeIsolating(:, cone) = ConeIsolating(:, cone) ./ ConeIsolating(1, cone);endConeIsolating% monitor calibrations from SDload EJMonitorSpectraFlashArea = 360^2;ScFact = 6.6e-34 * 3e8;StepSize = 1;WaveLen = 370:730;plot(WaveLen, EJMonitorSpectra(:, 1), WaveLen, EJMonitorSpectra(:, 2), WaveLen, EJMonitorSpectra(:, 3))UDTPower(1) = 3.9e-9;UDTPower(2) = 4.94e-9;UDTPower(3) = 4.99e-9;MonitorQuantalSpectra = EJMonitorSpectra;for led=1:3	LEDPow(led) = sum(EJMonitorSpectra(:, led)) * StepSize;	EJMonitorSpectra(:, led) = EJMonitorSpectra(:, led) * UDTPower(led) / LEDPow(led);	MonitorQuantalSpectra(:, led) = EJMonitorSpectra(:, led) .* WaveLen(:) * 1e-9 / (ScFact * FlashArea);endplot(WaveLen, MonitorQuantalSpectra(:, 1), WaveLen, MonitorQuantalSpectra(:, 2), WaveLen, MonitorQuantalSpectra(:, 3))% multiply LED spectra by cone spectrafor led=1:3	for cone = 2:4		MonitorPhotonFlux(cone-1, led) = sum(MonitorQuantalSpectra(:, led) .* MacaqueConeQuantalSpectra(:, cone));	endend% fit with nomogram